<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Jan Christiansen - Funktionale Frontend-Entwicklung</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="navigation">
                <a href="../">Jan Christiansen</a>
                <a href="../teaching/teaching.html">Veranstaltungen</a>
                <a href="../teaching/student-projects.html">Abschlussarbeiten/Projekte</a>
            </div>
        </div>

        <div id="content">
            <h1>Funktionale Frontend-Entwicklung</h1>
            <div class="info">
    Last changed on November 17, 2017
    
</div>

<p><a href="https://github.com/lpil/elm-companies">Elm Companies</a> bietet eine Liste von Firmen, die Elm in der Frontend-Entwicklung einsetzen.</p>
<h2 id="projekte">Projekte</h2>
<p>Auf dieser Seite werden Themenvorschläge für die Veranstaltung Funktionale Frontend-Entwicklung aufgelistet. Sie haben die Möglichkeit, entweder eine kleine Anwendung zu implementieren oder sich in Form einer wissenschaftlichen Arbeit in ein fortgeschrittenes Thema einzuarbeiten.</p>
<h3 id="information-flow-control-in-elm">Information-Flow Control in Elm</h3>
<p>Information-Flow Control wird genutzt, um zu verhindern, dass nicht-öffentliche Daten in einer Anwendung in öffentliche Kanäle geraten. Zu diesem Zweck soll ein Konzept entwickelt werden, wie der Ansatz aus der Arbeit <a href="https://pdfs.semanticscholar.org/4be7/7d8e77c95deac350e757220c45c051ace4f5.pdf">Two Can Keep a Secret, If One of Them Uses Haskell</a> in Elm eingesetzt werden kann. Zu diesem Zweck muss zuerst eine Elm-Anwendung entwickelt werden, die dem wiederkehrende Beispiel aus <a href="https://pdfs.semanticscholar.org/4be7/7d8e77c95deac350e757220c45c051ace4f5.pdf">Two Can Keep a Secret, If One of Them Uses Haskell</a> entspricht.</p>
<h3 id="modellierung-von-wahlen">Modellierung von Wahlen</h3>
<p>In diesem Projekt soll eine bestehende Elm-Anwendung erweitert werden. Die Anwendung wird genutzt, um Kennwerte von Wahlsystemen zu berechnen. Ein Beispiel für ein solches Wahlsystem ist der Ministerrat der europäischen Union. Eine Wahl besteht dabei aus einer Menge von Spielern, die jeweils ein Gewicht erhalten. Außerdem gibt es eine sogenannte Quota, die beschreibt, wie viele der Stimmen zusammenkommen müssen, damit die Wahl positiv entschieden wird. Wenn sich eine Koalition von Spielern findet, deren Gewichte zusammen mindestens die Quota erreichen, wird eine Entscheidung angenommen. Das <a href="https://jan-christiansen.github.io/legislative-bargaining-lab/">Legislative Bargaining Lab</a> stellt einen Prototypen der Implementierung zur Verfügung. Diese Anwendung soll verbessert und erweitert werden.</p>
<h3 id="elm-auf-microcontrollern">Elm auf Microcontrollern</h3>
<p>In diesem Projekt soll eine Elm-Anwendung auf einem Microcontroller ausgeführt werden. Microcontroller haben häufig eine Reihe von Sensoren und reagieren darauf, wenn einer dieser Sensoren Daten empfängt. Eine solche Anwendung passt grundsätzlich gut in das reaktive Muster einer Elm-Anwendung. Daher soll eine reaktive Architektur entwickelt werden, die sich zur Programmierung von Microcontrollern eignet. Um diesen Ansatz zu testen, soll mit Hilfe des Frameworks <a href="http://www.espruino.com">Espruino</a> eine einfache Elm-Anwendung auf einem Microcontroller ausgeführt werden. Espruino ist ein JavaScript-Interpreter, der auf einigen einfachen Microcontrollern läuft. Außerdem bietet Espruino Schnittstellen zu den wichtigsten Funktionen des Microcontrollers.</p>
<h3 id="processing-für-elm">Processing für Elm</h3>
<p>In diesem Projekt soll die Idee der Programmiersparche Processing auf die Programmiersprache Elm übertragen werden. Dabei geht es nicht darum, die gleiche Funktionalität bereitzustellen oder eine Anbindung umzusetzen sondern eine Programmiersprache zur Verfügung zu stellen, die für Designer und Künstler leicht zugänglich ist. Der Ansatz soll auf den Ideen von domänenspezifischen Sprachen aufbauen, um den Fachexperten eine einfache Nutzung der Sprache zu erlauben. Das Projekt <a href="https://p5js.org">p5.js</a> verfolgt einen ähnlichen Ansatz, in Form einer JavaScript-Bibliothek. Bei diesem Projekt ist insbesondere interessant, ob eine pure funktionale Programmiersprache wie Elm für diese Art der Anwendung gut oder schlecht geeignet ist.</p>
<!-- ### Debugging von Elm-Programmen

In diesem Projekt -->
<h3 id="elm-native-ui">Elm-Native-UI</h3>
<p>In diesem Projekt soll die Elm-Bibliothek <a href="https://github.com/ohanhi/elm-native-ui">Elm-Native-UI</a>, die auf der JavaScript-Bibliothek <a href="https://facebook.github.io/react-native/">React Native</a> aufsetzt, genutzt werden, um eine Anwendung für die Platformen iOS und Android in Elm zu entwickeln.</p>
<h3 id="elm-vr">Elm-VR</h3>
<p>In diesem Projekt soll die Elm-Bibliothek <a href="https://github.com/halfzebra/elm-aframe">elm-aframe</a>, die auf der JavaScript-Bibliothek <a href="https://aframe.io/docs/0.7.0/introduction/">A-Frame</a> aufsetzt, genutzt werden, um eine Anwendung im Bereich Virtual Reality in Elm zu entwickeln. Der Artikel <a href="https://medium.com/@tilman_s/easy-vr-with-elm-and-a-frame-a5c72cfb9945">Easy VR with Elm and A-Frame</a> gibt einen kurzen Einblick in die Nutzung der Bibliothek.</p>
<h3 id="spiel-in-elm">Spiel in Elm</h3>
<p>In diesem Projekt soll ein einfaches Spiel in Elm implementiert werden.</p>
<!-- ### CSS-Styling


### Implementierung von regulären Ausdrücken

In diesem Projekt soll


### Wahl der richtigen Datenstruktur

In Anlehnung an das Projekt
Datenstrukturen gegeneinander antreten lassen


### Visualisierung von Algorithmen

In diesem Projekt soll eine Visualisierung für einen einfachen Algorithmus umgesetzt werden.


### Programmierung für Anfänger

In dieser Arbeit


### Theorem-Proving Game


### Projektmanagement - The Game



### Dynamisch getyptes Elm?
-->
<h2 id="vorträge">Vorträge</h2>
<p>Wenn Sie eine der wissenschaftlichen Arbeiten vorstellen, sollten Sie auch einen Bezug zur Programmiersprache Elm herstellen. Das heißt, Sie sollten vorstellen, welche Bibliotheken es in diesem Bereich für Elm gibt bzw. was die Ergebnisse der Arbeit für die Programmiersprache Elm bedeuten.</p>
<h3 id="theorems-for-free-1989">Theorems for free! (1989)</h3>
<p>Die Arbeit <a href="http://www.cs.sfu.ca/CourseCentral/831/burton/Notes/July14/free.pdf">Theorems for free!</a> stellt die Idee der freien Theorem vor. Freie Theoreme sind Aussagen über funktionale Programme, die allein vom Typ einer Funktion abgeleitet werden können. Diese Aussagen hängen im Wesentlichen mit der Tatsache zusammen, dass polymorphe Funktionen keine Werte des polymorphen Typs erfinden können. Da eine Funktion außerdem keine Seiteneffekte ausführen kann, erhält man vergleichsweise starke Aussagen über polymorphe Funktionen, ohne deren Implementierung zu kennen. Die Arbeit war sehr einflussreich und freie Theoreme werden in vielen Bereichen genutzt, um Aussagen über funktionale Programme zu beweisen.</p>
<h3 id="a-short-cut-to-deforestation-1993">A short cut to deforestation (1993)</h3>
<p>Die Arbeit <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.224.4460&amp;rep=rep1&amp;type=pdf">A short cut to deforestation</a> stellt einen Ansatz zur <em>deforestation</em> vor. Bei der Programmierung in einer funktionalen Sprache werden sehr viele Zwischendatenstrukturen erzeugt. Wenn wir zum Beispiel zuerst die Funktion <em>map</em> und im Anschluss die Funktion <em>filter</em> auf eine Liste anwenden, wird durch <em>map</em> eine Liste erzeugt, die durch <em>filter</em> wieder konsumiert wird. Compiler-Optimierungen, die die Erzeugung solcher Zwischendatenstrukturen verhindern, bezeichnet man als <em>deforestation</em>. In dieser Arbeit wird einer der ersten Ansätze für <em>deforestation</em> präsentiert, der auch heute noch Verwendung findet.</p>
<h3 id="a-system-of-constructor-classes-overloading-and-implicit-higher-order-polymorphism-1995">A system of constructor classes: overloading and implicit higher-order polymorphism (1995)</h3>
<p>Die Arbeit <a href="http://web.cecs.pdx.edu/~mpj/pubs/fpca93.pdf">A system of constructor classes: overloading and implicit higher-order polymorphism</a> stellt eine der wichtigsten Abstraktionsmöglichkeiten vor, die Elm fehlt, aber Programmiersprachen wie Haskell zur Verfügung stellen, Typkonstruktorklassen. Dieses Konzept kann zum Beispiel genutzt werden, um die Implementierung eines Funktors für verschiedene Datentypen durch eine überladene Funktion zu abstrahieren. Typkonstruktorklassen sind außerdem die Grundlage für eine der berühmtesten und berüchtigsten Abstraktionen der Programmiersprache Haskell, Monaden.</p>
<h3 id="domain-specific-languages-1997">Domain-specific languages (1997)</h3>
<p>Die Arbeit <a href="http://haskell.cs.yale.edu/wp-content/uploads/2011/01/DSEL-Little.pdf">Domain-specific languages</a> stellt die Idee einer domänenspezifischen Sprache vor. Dabei wird eine einfache und eingeschränkte Programmiersprache entwickelt, die von Personen mit Domänenwissen genutzt wird. Eine Variante der domänenspezifischen Sprachen sind die eingebetteten domänenspezifischen Sprachen (EDSL). Dabei wird für die Sprache kein eigener Compiler entwickelt, sondern die Sprache wird in eine Host-Sprache eingebettet. Die Arbeit <a href="http://www.cse.chalmers.se/~emax/documents/svenningsson2013combining.pdf">Combining Deep and Shallow Embedding for EDSL</a> beschreibt die zwei Möglichkeiten zur Einbettung einer domänenspezifischen Sprache, ein <em>shallow</em> und ein <em>deep</em> <em>embedding</em>.</p>
<h3 id="monadic-parsing-in-haskell-1998">Monadic parsing in Haskell (1998)</h3>
<p>Die Arbeit <a href="http://www.cs.nott.ac.uk/~pszgmh/pearl.pdf">Monadic parsing in Haskell</a> stellt die Idee der Parserkombinatoren vor. Ein Parser ist eine Funktion, die eine Zeichenkette analysiert, zerlegt und in einen strukturierten Datentyp umwandelt. Parserkombinatoren bieten die Möglichkeit einen solchen Parser einfach zu definieren, indem die zur Verfügung gestellten Kombinatoren verwendet werden. Parserkombinatoren sind ein Beispiel für eine <em>embedded domain specific language</em> (EDSL), das heißt, für eine Sprache für einen ganz spezifischen Zweck, die in einer anderen Sprache eingebettet ist. Die Idee der Parserkombinatoren wurde inzwischen in einer Vielzahl von Programmiersprachen implementiert, so gibt es Bibliotheken für Parserkombinatoren zum Beispiel in Java, C#, Ruby, C++, Python und JavaScript.</p>
<h3 id="quickcheck-a-lightweight-tool-for-random-testing-of-haskell-programs-2000">QuickCheck: a lightweight tool for random testing of Haskell programs (2000)</h3>
<p>Die Arbeit <a href="http://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf">QuickCheck: a lightweight tool for random testing of Haskell programs</a> stellt eine Bibliothek mit dem Namen QuickCheck und das Konzept des <em>property-based testing</em> vor. Während bei einem Unit-Test normalerweise eine Eigenschaft für ein paar Beispieleingaben getestet wird, wird beim <em>property-based testing</em> eine Eigenschaft für sehr viele, zufällig generierte Eingaben getestet. Auf diese Weise kann eine Funktion ohne großen Aufwand für eine Vielzahl von Testfällen getestet werden. Die Erzeugung der Testeingaben wird durch die Struktur des Typs der Eingaben geleitet. Die Idee des <em>property-based testing</em> hat inzwischen Einzug in fast statisch getypten Programmiersprachen gehalten. So gibt es Reimplementierungen des QuickCheck-Ansatzes in Programmiersprachen wie Scala, Java, Swift und Objective-C.</p>
<h3 id="generics-for-the-masses-2004">Generics for the masses (2004)</h3>
<p>Die Arbeit <a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/ICFP04.pdf">Generics for the masses</a> stellt einen Ansatz zur generischen Programmierung in Haskell vor. Die generische Programmierung erlaubt es, eine einzelne Funktion zu definieren, die auf einer Vielzahl von Typen genutzt werden kann. Im Unterschied zu einer polymorphen Funktion verhält sich eine generische Funktion nicht für alle Typen gleich, sondern trifft Entscheidungen abhängig von der Struktur des Typs. Typische Beispiele für generische Funktionen sind etwa die strukturelle Gleichheit von Werten oder die Funktion <em>toString</em>, die eine String-Darstellung eines Wertes liefert. Solche Funktionen können mit Hilfe der generischen Programmierung ein einziges Mal definiert und dann für verschiedene algebraische Datentypen genutzt werden.</p>
<h3 id="probabilistic-functional-programming-in-haskell-2006">Probabilistic functional programming in Haskell (2006)</h3>
<p>Probabilistische Programmiersprachen erlauben es, einfach die Berechnung von Wahrscheinlichkeiten zu modellieren. Solche Programmiersprachen werden zum Beispiel im Bereich der künstlichen Intelligenz zur Modellierung von neuronalen Netzen genutzt. Die Arbeit <a href="http://icerote.net/doc/library/programming/fp/Probabilistic%20functional%20programming%20in%20Haskell.pdf">Probabilistic functional programming in Haskell</a> demonstriert, wie man in Haskell eine Bibliothek zur probabilistischen Programmierung einfach mit Hilfe einer monadischen Abstraktion implementieren kann. Die Bibliothek ist ein Beispiel für eine <em>embedded domain specific language</em> (EDSL), das heißt, für eine Sprache für einen ganz spezifischen Zweck, die in eine andere Programmiersprache eingebettet ist.</p>
<h3 id="liquidhaskell-experience-with-refinement-types-in-the-real-world-2014">Liquidhaskell: Experience with refinement types in the real world (2014)</h3>
<p>Liquidhaskell ist eine Implementierung von <em>refinement types</em> für Haskell. Ein Typsystem mit <em>refinement types</em> erlaubt es, sehr viel stärkere Aussagen über Programme zu treffen als es mit Typsystemen wie dem von Elm möglich ist. So ist es zum Beispiel möglich im Typ die Länge einer Liste auszudrücken. Damit erhält man zum Beispiel die Garantie, dass man nie versucht, auf einen Index außerhalb einer Liste zuzugreifen. Typsysteme wie <em>refinement types</em> eignen sich gut, um sicherheitskritische Anwendungen zu entwickeln. Die Arbeit <a href="http://goto.ucsd.edu/~nvazou/real_world_liquid.pdf">Liquidhaskell: Experience with refinement types in the real world</a> stellt die Haskell-Bibliothek an einer Reihe von Beispielen vor und zeigt, welche Arten von Garantieren, man mit Hilfe dieser Typen über Programme erhält. Der <a href="https://ucsd-progsys.github.io/liquidhaskell-blog/">Blog</a> bietet eine ganze Reihe von Artikeln mit motivierenden Beispielen, wie man <em>refinement types</em> nutzen kann, um Garantien über Programme zu erhalten.</p>
<h3 id="propositions-as-types-2015">Propositions as types (2015)</h3>
<p>In der Arbeit <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.673.269&amp;rep=rep1&amp;type=pdf">Propositions as types</a> geht es um den Zusammenhang zwischen Logik und den Typen in einer funktionalen Programmiersprache. Der Artikel ist in den Communications of the ACM erschienen, einer monatlichen Serie von Artikeln der amerikanischen Gesellschaft für Informatik. Daher adressiert der Artikel Personen aus allen Bereichen der Informatik. Das Thema an sich ist eher abstrakt und beleuchtet einen sehr grundlegenden Zusammenhang zwischen zwei formalen Systemen. Daher erfordert er ein Grundverständnis von formalen Systemen in der Informatik. Der Artikel illustriert, warum jeder Programmier, der in einer statisch getypten Sprache wie Elm oder Java programmiert, tagtäglich mathematische Beweise führt.</p>
<h3 id="all-sorts-of-permutations-2016">All Sorts of Permutations (2016)</h3>
<p>Die Arbeit <a href="http://informatik.uni-kiel.de/~sad/icfp2016-preprint.pdf">All Sorts of Permutations</a> demonstriert einen Zusammenhang zwischen Sortieren und Permutieren in Haskell. Sortieren beschreibt dabei die Aufgabe mit Hilfe einer Vergleichsfunktion eine Liste von Werten in die richtige Reihenfolge zu bringen. Beim Permutieren wird für eine Liste jede mögliche Reihenfolge der Liste generiert. Der Zusammenhang basiert darauf, dass man zwei verschiedene Instanzen einer monadischen Funktion betrachtet. Dieser Zusammenhang ist nicht auf Sortieren und Permutieren beschränkt, sondern lässt sich auch auf andere Funktionen anwenden, zum Beispiel auf die Funktion <em>filter</em>.</p>
<!-- ### Debugging Haskell by Observing Intermediate Data Structures - A. Gill (2000)

Da funktionale Programme sehr viel abstrakter sind als imperative Programme, lassen sich Konzepte zum Debuggen von Programmen nicht einfach von imperativen auf funktionale Programmiersprachen übertragen. Diese Arbeit stellt ein Konzept zum Debuggen von funktionalen Programmen vor, das sich als einfache Bibliothek implementieren lässt. Das heißt, es ist nicht notwendig, den Compiler abzuändern, sondern der Debugger steht durch eine einfache Import-Anweisung zur Verfügung. Die vorgestellte Form des Debuggings eignet sich besonders gut, um das Verhalten der Faulheit zu observieren. [Veröffentlichung](http://www.ittc.ku.edu/~andygill/papers/Hood00.pdf)


### Tackling the awkward squad - S. P. Jones (2010)

Die Arbeit zeigt, wie einige Konzepte der imperativen Programmierung in Haskell integriert werden. Zuerst wird illustriert, wie die IO-Monade implementiert ist und wie diese formal modelliert werden kann. Daneben werden noch Konzepte wie veränderbare Speicherzellen, Nebenläufigkeit, Ausnahmebehandlung und das Foreign Function Interface (FFI) vorgestellt. Das FFI stellt ein Konzept zur Verfügung, um andere Programmiersprachen, zum Beispiel C, an Haskell anzubinden. Es handelt sich bei der Arbeit um Lecture Notes, die Simon Peyton Jones bereits im Jahr 2000 bei einer Summer School verwendet hat. Das Dokument wurde seitdem mehrfach überarbeitet und an den aktuellen Stand angepasst. [Veröffentlichung](http://research.microsoft.com/en-us/um/people/simonpj/Papers/marktoberdorf/mark.pdf.gz)


### Concurrent haskell - S. P. Jones and A. Gordon and S. Finne (1996)

Die Arbeit stellt die Bibliothek Concurrent Haskell vor. Diese Bibliothek kann genutzt werden, um nebenläufige Programme, also Programme mit Threads und geteilten Ressourcen, in Haskell zu schreiben. Während das Abstraktionsniveau der Bibliothek relativ niedrig ist, da es sich um die erste Bibliothek dieser Art für Haskell handelt, sind Konzepte wie geteilte Variable und Semaphore so klar umgesetzt, dass die Bibliothek sich immer noch gut eignet, um grundlegende Algorithmen der nebenläufigen Programmierung klar zu modellieren. [Veröffentlichung](http://research.microsoft.com/en-us/um/people/simonpj/papers/concurrent-haskell.pdf)


### Composable memory transactions - T. Harris and S. Marlow and S. Peyton-Jones and M. Herlihy (2005)

Diese Arbeit stellt das Konzept des Software Transactional Memory (STM) vor. Dieses Konzept lehnt sich an das Transaktionskonzept aus dem Bereich der Datenbanken an und kann genutzt werden, um einfacher nebenläufige Programme zu schreiben. Dabei werden Änderungen an geteilten Variablen nur vorgenommen, wenn alle beteiligten Threads einen konsistenten Blick auf die Werte der veränderten Variablen hatten. Auf diese Weise können nebenläufige Programme auf einer hohen Abstraktionsebene implementiert werden. Das STM-Konzept wurde auch für andere Programmiersprachen implementiert, konnte sich dort aber, auf Grund von Seiteneffekten, die nicht mit diesem Ansatz harmonieren, nicht durchsetzen. [Veröffentlichung](https://cs.uwaterloo.ca/~Brecht/courses/702/Possible-Readings/transactional-memory/composable-mem-trans-ppopp-2005.pdf)


### Two can keep a secret, if one of them uses Haskell - A. Russo (2015)

In dieser Arbeit wird eine Bibliothek für _Mandatory Access Control (MAC)_ oder _Information-Flow Control (IFC)_ vorgestellt. Während der erste Begriff aus dem Bereich der Betriebssysteme stammt, kommt der zweite Begriff aus dem Bereich der Programmiersprachen. Die Arbeit zeigt, wie man mit Hilfe des Typsystems von Haskell eine Bibliothek entwerfen kann, die nur eingeschränkten Zugriff auf gewisse Informationen erlaubt. [Veröffentlichung](https://pdfs.semanticscholar.org/4be7/7d8e77c95deac350e757220c45c051ace4f5.pdf)


### Type-Level Web APIs with Servant - A. Mestanogullari and S. Hahn and J. K. Arni and A. Löh (2015)

Servant ist eine Haskell-Bibliothek zur Entwicklung von Http-Servern. Die Bibliothek stellt Konzepte zur Verfügung, um typsicher Http-Schnittstellen zu beschreiben. Wird an der Beschreibung eine Änderung vorgenommen, kann das Programm erst wieder übersetzt werden, wenn die Dienste, die die Schnittstelle nutzen, ebenfalls angepasst sind. Da diese Arbeit vergleichsweise aktuell ist, kommen einige der aktuelleren Typ-Erweiterungen von Haskell zum Einsatz. Zum einen kann man an dieser Arbeit schön sehen, was man mit Hilfe dieser Erweiterungen alles ausdrücken kann, zum anderen muss man in Kauf nehmen, dass man sich in einige der Erweiterungen zumindest teilweise einlesen muss. [Veröffentlichung](http://alpmestan.com/servant/servant-wgp.pdf)


### Vorstellung der Programmiersprache Coq

Coq ist eine funktionale Programmiersprache, die außerdem einen interaktiven Beweisassistenten zur Verfügung stellt, um Aussagen über die Programme zu beweisen. Das heißt, man kann zum Beispiel funktionale Programme in Coq schreiben und dann Aussagen über diese Programme beweisen. Ein Beweis besteht dabei aus einer Reihe von Schritten, die man ebenfalls in die Programmdatei schreibt. Der Compiler überprüft dann beim Übersetzen des Programms, ob die Schritte des Beweises richtig sind. Man kann mit Hilfe von Coq aber nicht nur Aussagen über funktionale Programme beweisen. So wurde zum Beispiel mit Hilfe von Coq die Korrektheit eines [C-Compilers](http://compcert.inria.fr) bewiesen, der zum Beispiel bei der Entwicklung von hoch-sicherheitskritischen Systemen wie Atomkraftwerken zum Einsatz kommt. Die Korrektheit des C-Compilers stellt sicher, dass der C-Compiler bei der Übersetzung und Optimierung des Codes die Bedeutung des Programms nicht verändert. [Internetseite](https://coq.inria.fr)


### A tutorial on the universality and expressiveness of fold - G. Hutton (1999)

Diese Arbeit diskutiert die Funktion _fold_ auf einer Liste und welche Art von Funktionen man mit Hilfe der Funktion _fold_ definieren kann. Grundsätzlich gibt es bestimmte Arten von Rekursion, die sich nicht durch ein _fold_ ausdrücken lassen. Es zeigt sich aber, dass sich in einer funktionalen Programmiersprache mehr Funktionen mit Hilfe von _fold_ ausdrücken lassen, als man auf den ersten Blick vermuten würde. [Veröffentlichung](http://eprints.nottingham.ac.uk/224/1/fold.pdf)


### The under-appreciated unfold -J. Gibbons and G. Jones (1998)

Neben der Funktion _fold_ gibt es noch die Funktion _unfold_, die eine Art Gegenspieler zur Funktion _fold_ darstellt. Während _fold_ eine Liste konsumiert, ist es mit der Funktion _unfold_ möglich, eine Liste zu generieren. Während die Idee eines Folds inzwischen auch in anderen Programmiersprachen zum Einsatz kommt, ist die Funktion _unfold_ auch in Haskell immer noch vergleichsweise selten in Gebrauch. Die Arbeit stellt eine Implementierung einer Breitensuche auf einem Baum mit Hilfe der Funktion _unfold_ vor. [Veröffentlichung](http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/unfold.ps.gz)


### Monad transformers and modular interpreters - S. Liang and P. Hudak and M. Jones (1995)

In dieser Arbeit werden _monad transformer_ vorgestellt. Diese erlauben es, mehrere Monaden zu einer neuen Monade zu kombinieren und damit Effekte, die durch eine Monade definiert werden können, zu kombinieren. In praktischen Anwendungen kommen solche _monad stacks_ sehr häufig zum Einsatz, weshalb die Vor- und Nachteile von _monad transformer_ immer noch ein Thema aktueller Forschung sind. [Veröffentlichung](https://pdfs.semanticscholar.org/a10b/695bbadd23ba02f4355e9aa2626245f0f5c8.pdf)


### Programming with arrows - J. Hughes (2004)

Arrows sind, ähnlich wie Monaden ein allgemeines Konzept zur Abstraktion. Die Arbeit stellt die Idee der _arrows_ sowie praktische Anwendungen dieser Abstraktion vor. Die Arbeit ist vergleichsweise lang, dafür setzt sie aber nur ein geringes Vorwissen voraus, da es sich um den Inhalt einer fortgeschrittenen Vorlesung handelt. [Veröffentlichung](https://karczmarczuk.users.greyc.fr/TEACH/Doc/afp-arrows.pdf)


### Applicative programming with effects - C. McBride and R. Paterson (2008)

Diese Arbeit stellt die Typklasse _Applicative_ vor. Diese Typklasse stellt ähnlich wie eine Monade eine Abstraktion verschiedener Strukturen dar. Die Typklassen _Monad_ und _Applicative_ sind sehr eng miteinander verwandt. Einige Strukturen erfüllen die Anforderung der Typklasse _Applicative_, sind aber keine Monade. Die Entwicklung der Typklasse _Applicative_ wurde vor allem durch Entwicklungen im Bereich der Parserkombinatoren vorangetrieben, erwies sich aber als sehr viel grundlegender. [Veröffentlichung](http://staff.city.ac.uk/~ross/papers/Applicative.pdf)


#### Explaining binomial heaps - R. Hinze (1999)

Die Arbeit führt die Datenstruktur _binomial heap_ ein und ist explizit für Leser mit grundlegenden Haskell-Kenntnissen geschrieben. Die Datenstruktur fasst ähnlich wie eine Liste mehrere Werte zusammen und erlaubt effizientes Einfügen von neuen Elementen und Finden und Entfernen des minimalen Elementes im Heap. Ein binomial Heap eignet sich zum Beispiel zur Implementierung einer Prioritäten-Warteschlange. [Veröffentlichung](https://www.google.de/url?sa=t&rct=j&q=&esrc=s&source=web&cd=2&ved=0ahUKEwj_rqGuqd3PAhWE2CwKHTeEBjcQFgghMAE&url=http%3A%2F%2Fwww.cs.ox.ac.uk%2Fralf.hinze%2Fpublications%2FBinomialHeaps.ps.gz&usg=AFQjCNEZRErn829vcyom1zPUR822jDGwlA&bvm=bv.135974163,d.bGg)


#### Inductive graphs and functional graph algorithms - M. Erwig (2001)

Graphen lassen sich in funktionalen Programmiersprachen nicht sehr gut abbilden, da Werte in funktionalen Sprachen immer auf Wertgleichheit getestet werden und nicht auf Referenzgleichheit. Daher lassen sich die klassischen Implementierungen von Graphalgorithmen nicht direkt in eine funktionale Programmiersprache übersetzen. Diese Arbeit stellt eine Modellierung von Graphen vor, die sehr viel besser in das funktionale Programmierparadigma passt. [Veröffentlichung](https://www.researchgate.net/profile/Martin_Erwig/publication/2364482_Inductive_Graphs_and_Functional_Graph_Algorithms/links/5439ae4f0cf2d6698be167f3.pdf)


#### Uniqueness typing simplified - E. De Vries and R. Plasmeijer and D. M. Abrahamson (2007)

In einem Typsystem mit _uniqueness types_ können bestimmte Variablen nur ein einziges Mal genutzt werden. Das Typsystem stellt dabei sicher, dass bestimmte Variablen tatsächlich nur einmal genutzt werden. Nutzt man eine solche Variablen in einem Programm mehrfach, liefert der Compiler einen Typfehler und das Programm lässt sich nicht übersetzen. Ein solches Typsystem kommt der in der funktionalen Programmiersprache Clean zum Einsatz, um Seiteneffekte in die Sprache zu integrieren. [Veröffentlichung](https://pdfs.semanticscholar.org/42e7/e8c61a43578cafb8c9ed939d948f09c5e393.pdf)

-->

        </div>

        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
