<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Jan Christiansen - Fortgeschrittene funktionale Programmierung</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="navigation">
                <a href="../">Jan Christiansen</a>
                <a href="../teaching/teaching.html">Veranstaltungen</a>
                <a href="../teaching/student-projects.html">Abschlussarbeiten/Projekte</a>
            </div>
        </div>

        <div id="content">
            <h1>Fortgeschrittene funktionale Programmierung</h1>
            <div class="info">
    Last changed on February  7, 2017
    
</div>

<!-- ## Inhalt

Die Ideen der funktionalen Programmierung halten zunehmend Einzug in die
kommerzielle Software­entwicklung, wie zum Beispiel durch die Entwicklung der
funktional objekt-orientierten Programmier­sprache Swift deutlich wird.

In der Vorlesung lernen Sie die Prinzipien und Entwicklungs­muster der
funktionalen Programmierung anhand der stark-getypten, rein-funktionalen
Programmiersprache Haskell kennen. Neben Grundlagen wie Lazy Evaluation,
Higher-Order Functions und Polymorphismus werden Abstraktions­mechanismen wie
Monoide, Funktoren und Monaden vorgestellt.

Am Ende arbeiten Sie sich eigenständig in ein fortgeschrittenes Thema Ihrer Wahl
ein. Mögliche Themen sind zum Beispiel: funktionale Datenstrukturen, typsichere
Webentwicklung (PureScript/Elm, Servant), freie Theoreme, Grundlagen der
Kategorientheorie.


## Lernvoraussetzungen

Obwohl die Vorlesung "fortgeschritten" heißt, werden alle Konzepte von Grund auf
eingeführt; es werden keinerlei Kenntnisse in der funktionalen Programmierung
vorausgesetzt. Es wird jedoch erwartet, dass Sie bereits praktische Erfahrungen
in der Programmierung in anderen Programmier­sprachen wie JavaScript, Java oder
C# mitbringen und somit in der Lage sind, schnell eine neue Programmier­sprache
zu erlernen.


## Literatur

M. Lipovaca: Learn You a Haskell for Great Good!. No Starch Press (2011)
B. O'Sullivan, J. Goerzen, D.B. Stewart: Real World Haskell. O'Reilly (2010) -->
<h2 id="vortrag">Vortrag</h2>
<p>Als Anhaltspunkt für gute Vorträge kann der Vortrag <a href="https://www.microsoft.com/en-us/research/academic-program/give-great-research-talk/">“How to give a great research talk”</a> von Simon Peyton-Jones genutzt werden. Simon Peyton-Jones ist einer der beiden Hauptentwickler des ghc, eine der treibenden Kräfte der funktionalen Programmierung in den letzten 30 Jahren und einer der bekanntesten Forscher in diesem Bereich. Nebenbei hält er noch sehr unterhaltsame Vorträge zu Arbeiten mit eigentlich recht kompliziertem Inhalt.</p>
<h2 id="themenvorschläge">Themenvorschläge</h2>
<h3 id="typen">Typen</h3>
<h4 id="theorems-for-free---p.-wadler-1989">Theorems for free! - P. Wadler (1989)</h4>
<p>Freie Theoreme sind Aussagen über funktionale Programme, die allein vom Typ einer Funktion abgeleitet werden können. Diese Aussagen hängen im Wesentlichen mit der Tatsache zusammen, dass polymorphe Funktionen keine Werte des polymorphen Typs erfinden können. Da eine Funktion außerdem keine Seiteneffekte ausführen kann, erhält man vergleichsweise starke Aussagen über polymorphe Funktionen, ohne deren Implementierung zu kennen. Die Arbeit war sehr einflussreich und freie Theoreme werden in vielen Bereichen genutzt, um Aussagen über funktionale Programme zu beweisen. <a href="http://www.cs.sfu.ca/CourseCentral/831/burton/Notes/July14/free.pdf">Veröffentlichung</a></p>
<h4 id="uniqueness-typing-simplified---e.-de-vries-and-r.-plasmeijer-and-d.-m.-abrahamson-2007">Uniqueness typing simplified - E. De Vries and R. Plasmeijer and D. M. Abrahamson (2007)</h4>
<p>In einem Typsystem mit <em>uniqueness types</em> können bestimmte Variablen nur ein einziges Mal genutzt werden. Das Typsystem stellt dabei sicher, dass bestimmte Variablen tatsächlich nur einmal genutzt werden. Nutzt man eine solche Variablen in einem Programm mehrfach, liefert der Compiler einen Typfehler und das Programm lässt sich nicht übersetzen. Ein solches Typsystem kommt der in der funktionalen Programmiersprache Clean zum Einsatz, um Seiteneffekte in die Sprache zu integrieren. <a href="https://pdfs.semanticscholar.org/42e7/e8c61a43578cafb8c9ed939d948f09c5e393.pdf">Veröffentlichung</a></p>
<h4 id="liquidhaskell-experience-with-refinement-types-in-the-real-world---n.-vazou-and-e.-l.-seidel-and-r.-jhala-2014">Liquidhaskell: Experience with refinement types in the real world - N. Vazou and E. L. Seidel and R. Jhala (2014)</h4>
<p>Liquidhaskell ist eine Implementierung von <em>refinement types</em> für Haskell. Ein Typsystem mit <em>refinement types</em> erlaubt es, sehr viel stärkere Aussagen über Programme zu treffen als es mit Typsystemen wie dem von Haskell möglich ist. So ist es zum Beispiel möglich im Typ die Länge einer Liste auszudrücken. Damit erhält man zum Beispiel die Garantie, dass man nie versucht, auf einen Index außerhalb einer Liste zuzugreifen. Typsysteme wie <em>refinement types</em> eignen sich gut, um sicherheitskritische Anwendungen zu entwickeln. Die Arbeit stellt die Haskell-Bibliothek an einer Reihe von Beispielen vor und zeigt, welche Arten von Garantieren, man mit Hilfe dieser Typen über Programme erhält. <a href="http://goto.ucsd.edu/~nvazou/real_world_liquid.pdf">Veröffentlichung</a></p>
<h4 id="propositions-as-types---p.-wadler-2015">Propositions as types - P. Wadler (2015)</h4>
<p>In dieser Arbeit geht es um den Zusammenhang zwischen Logik und den Typen in einer funktionalen Programmiersprache. Die Arbeit ist relativ verständlich geschrieben und erfordert wenig Vorwissen, da es sich nicht um eine wissenschaftliche Veröffentlichung sondern um eine Art Zeitschriftenartikel handelt. Der Artikel ist in den Communications of the ACM erschienen, einer monatlichen Serie von Artikeln der amerikanischen Gesellschaft für Informatik. Daher adressiert der Artikel Personen aus allen Bereichen der Informatik. Das Thema an sich ist aber sehr abstrakt und beleuchtet einen sehr grundlegenden Zusammenhang zwischen zwei formalen Systemen. Daher erfordert er ein Grundverständnis von formalen Systemen in der Informatik. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.673.269&amp;rep=rep1&amp;type=pdf">Veröffentlichung</a></p>
<h3 id="compiler-optimierungen">Compiler-Optimierungen</h3>
<h4 id="a-short-cut-to-deforestation---a.-gill-and-j.-launchbury-and-s.-l.-peyton-jones-1993">A short cut to deforestation - A. Gill and J. Launchbury and S. L. Peyton Jones (1993)</h4>
<p>Bei der Programmierung in einer funktionalen Sprache werden sehr viele Zwischendatenstrukturen erzeugt. Wenn wir zum Beispiel zuerst die Funktion <em>map</em> und im Anschluss die Funktion <em>filter</em> auf eine Liste anwenden, wird durch <em>map</em> eine Liste erzeugt, die durch <em>filter</em> wieder konsumiert wird. Compiler-Optimierungen, die die Erzeugung solcher Zwischendatenstrukturen verhindern, bezeichnet man als <em>deforestation</em>. In dieser Arbeit wird einer der ersten Ansätze für <em>deforestation</em> präsentiert, der auch heute noch Verwendung findet. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.224.4460&amp;rep=rep1&amp;type=pdf">Veröffentlichung</a></p>
<h3 id="abstraktionen">Abstraktionen</h3>
<h4 id="a-tutorial-on-the-universality-and-expressiveness-of-fold---g.-hutton-1999">A tutorial on the universality and expressiveness of fold - G. Hutton (1999)</h4>
<p>Diese Arbeit diskutiert die Funktion <em>fold</em> auf einer Liste und welche Art von Funktionen man mit Hilfe der Funktion <em>fold</em> definieren kann. Grundsätzlich gibt es bestimmte Arten von Rekursion, die sich nicht durch ein <em>fold</em> ausdrücken lassen. Es zeigt sich aber, dass sich in einer funktionalen Programmiersprache mehr Funktionen mit Hilfe von <em>fold</em> ausdrücken lassen, als man auf den ersten Blick vermuten würde. <a href="http://eprints.nottingham.ac.uk/224/1/fold.pdf">Veröffentlichung</a></p>
<h4 id="the-under-appreciated-unfold--j.-gibbons-and-g.-jones-1998">The under-appreciated unfold -J. Gibbons and G. Jones (1998)</h4>
<p>Neben der Funktion <em>fold</em> gibt es noch die Funktion <em>unfold</em>, die eine Art Gegenspieler zur Funktion <em>fold</em> darstellt. Während <em>fold</em> eine Liste konsumiert, ist es mit der Funktion <em>unfold</em> möglich, eine Liste zu generieren. Während die Idee eines Folds inzwischen auch in anderen Programmiersprachen zum Einsatz kommt, ist die Funktion <em>unfold</em> auch in Haskell immer noch vergleichsweise selten in Gebrauch. Die Arbeit stellt eine Implementierung einer Breitensuche auf einem Baum mit Hilfe der Funktion <em>unfold</em> vor. <a href="http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/unfold.ps.gz">Veröffentlichung</a></p>
<h4 id="monad-transformers-and-modular-interpreters---s.-liang-and-p.-hudak-and-m.-jones-1995">Monad transformers and modular interpreters - S. Liang and P. Hudak and M. Jones (1995)</h4>
<p>In dieser Arbeit werden <em>monad transformer</em> vorgestellt. Diese erlauben es, mehrere Monaden zu einer neuen Monade zu kombinieren und damit Effekte, die durch eine Monade definiert werden können, zu kombinieren. In praktischen Anwendungen kommen solche <em>monad stacks</em> sehr häufig zum Einsatz, weshalb die Vor- und Nachteile von <em>monad transformer</em> immer noch ein Thema aktueller Forschung sind. <a href="https://pdfs.semanticscholar.org/a10b/695bbadd23ba02f4355e9aa2626245f0f5c8.pdf">Veröffentlichung</a></p>
<h4 id="programming-with-arrows---j.-hughes-2004">Programming with arrows - J. Hughes (2004)</h4>
<p>Arrows sind, ähnlich wie Monaden ein allgemeines Konzept zur Abstraktion. Die Arbeit stellt die Idee der <em>arrows</em> sowie praktische Anwendungen dieser Abstraktion vor. Die Arbeit ist vergleichsweise lang, dafür setzt sie aber nur ein geringes Vorwissen voraus, da es sich um den Inhalt einer fortgeschrittenen Vorlesung handelt. <a href="https://karczmarczuk.users.greyc.fr/TEACH/Doc/afp-arrows.pdf">Veröffentlichung</a></p>
<h4 id="generics-for-the-masses---r.-hinze-2004">Generics for the masses - R. Hinze (2004)</h4>
<p>Diese Arbeit stellt einen Ansatz zur generischen Programmierung in Haskell vor. Die generische Programmierung erlaubt es, eine einzelne Funktion zu definieren, die auf einer Vielzahl von Typen genutzt werden kann. Im Unterschied zu einer polymorphen Funktion verhält sich eine generische Funktion nicht für alle Typen gleich, sondern trifft Entscheidungen abhängig von der Struktur des Typs. Typische Beispiele für generische Funktionen sind zum Beispiel die strukturelle Gleichheit von Werten oder die Funktion <em>show</em>. <a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/ICFP04.pdf">Veröffentlichung</a></p>
<h4 id="applicative-programming-with-effects---c.-mcbride-and-r.-paterson-2008">Applicative programming with effects - C. McBride and R. Paterson (2008)</h4>
<p>Diese Arbeit stellt die Typklasse <em>Applicative</em> vor. Diese Typklasse stellt ähnlich wie eine Monade eine Abstraktion verschiedener Strukturen dar. Die Typklassen <em>Monad</em> und <em>Applicative</em> sind sehr eng miteinander verwandt. Einige Strukturen erfüllen die Anforderung der Typklasse <em>Applicative</em>, sind aber keine Monade. Die Entwicklung der Typklasse <em>Applicative</em> wurde vor allem durch Entwicklungen im Bereich der Parserkombinatoren vorangetrieben, erwies sich aber als sehr viel grundlegender. <a href="http://staff.city.ac.uk/~ross/papers/Applicative.pdf">Veröffentlichung</a></p>
<h4 id="all-sorts-of-permutations---j.-christiansen-and-n.-danilenko-and-s.-dylus-2016">All Sorts of Permutations - J. Christiansen and N. Danilenko and S. Dylus (2016)</h4>
<p>Diese Arbeit demonstriert einen Zusammenhang zwischen Sortieren und Permutieren in Haskell. Sortieren beschreibt dabei die Aufgabe mit Hilfe einer Vergleichsfunktion eine Liste von Werten in die richtige Reihenfolge zu bringen. Beim Permutieren wird für eine Liste jede mögliche Reihenfolge der Liste generiert. Der Zusammenhang basiert darauf, dass man zwei verschiedene Instanzen einer monadischen Funktion betrachtet. Dieser Zusammenhang ist nicht auf Sortieren und Permutieren beschränkt, sondern lässt sich auch auf andere Funktionen anwenden, zum Beispiel auf die Funktion <em>filter</em>. <a href="http://informatik.uni-kiel.de/~sad/icfp2016-preprint.pdf">Veröffentlichung</a></p>
<h3 id="datenstrukturen">Datenstrukturen</h3>
<h4 id="explaining-binomial-heaps---r.-hinze-1999">Explaining binomial heaps - R. Hinze (1999)</h4>
<p>Die Arbeit führt die Datenstruktur <em>binomial heap</em> ein und ist explizit für Leser mit grundlegenden Haskell-Kenntnissen geschrieben. Die Datenstruktur fasst ähnlich wie eine Liste mehrere Werte zusammen und erlaubt effizientes Einfügen von neuen Elementen und Finden und Entfernen des minimalen Elementes im Heap. Ein binomial Heap eignet sich zum Beispiel zur Implementierung einer Prioritäten-Warteschlange. <a href="https://www.google.de/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=2&amp;ved=0ahUKEwj_rqGuqd3PAhWE2CwKHTeEBjcQFgghMAE&amp;url=http%3A%2F%2Fwww.cs.ox.ac.uk%2Fralf.hinze%2Fpublications%2FBinomialHeaps.ps.gz&amp;usg=AFQjCNEZRErn829vcyom1zPUR822jDGwlA&amp;bvm=bv.135974163,d.bGg">Veröffentlichung</a></p>
<h4 id="inductive-graphs-and-functional-graph-algorithms---m.-erwig-2001">Inductive graphs and functional graph algorithms - M. Erwig (2001)</h4>
<p>Graphen lassen sich in funktionalen Programmiersprachen nicht sehr gut abbilden, da Werte in funktionalen Sprachen immer auf Wertgleichheit getestet werden und nicht auf Referenzgleichheit. Daher lassen sich die klassischen Implementierungen von Graphalgorithmen nicht direkt in eine funktionale Programmiersprache übersetzen. Diese Arbeit stellt eine Modellierung von Graphen vor, die sehr viel besser in das funktionale Programmierparadigma passt. <a href="https://www.researchgate.net/profile/Martin_Erwig/publication/2364482_Inductive_Graphs_and_Functional_Graph_Algorithms/links/5439ae4f0cf2d6698be167f3.pdf">Veröffentlichung</a></p>
<h3 id="testen">Testen</h3>
<h4 id="quickcheck-a-lightweight-tool-for-random-testing-of-haskell-programs---k.-claessen-and-j.-hughes-2000">QuickCheck: a lightweight tool for random testing of Haskell programs - K. Claessen and J. Hughes (2000)</h4>
<p>Diese Arbeit stellt eine Bibliothek mit dem Namen QuickCheck und das Konzept des <em>property-based testing</em> vor. Während bei einem Unit-Test normalerweise eine Eigenschaft für ein paar Beispieleingaben getestet wird, wird beim <em>property-based testing</em> eine Eigenschaft für sehr viele, zufällig generierte Eingaben getestet. Auf diese Weise kann eine Funktion ohne großen Aufwand für eine Vielzahl von Testfällen getestet werden. Die Erzeugung der Testeingaben wird durch die Struktur des Typs der Eingaben geleitet. Die Idee des <em>property-based testing</em> hat inzwischen Einzug in fast alle stark getypten Programmiersprachen gehalten. So gibt es reimplementieren des QuickCheck-Ansatzes in Programmiersprachen wie Scala, Java, Swift und Objective-C. <a href="http://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf">Veröffentlichung</a></p>
<h4 id="debugging-haskell-by-observing-intermediate-data-structures---a.-gill-2000">Debugging Haskell by Observing Intermediate Data Structures - A. Gill (2000)</h4>
<p>Da funktionale Programme sehr viel abstrakter sind als imperative Programme, lassen sich Konzepte zum Debuggen von Programmen nicht einfach von imperativen auf funktionale Programmiersprachen übertragen. Diese Arbeit stellt ein Konzept zum Debuggen von funktionalen Programmen vor, das sich als einfache Bibliothek implementieren lässt. Das heißt, es ist nicht notwendig, den Compiler abzuändern, sondern der Debugger steht durch eine einfache Import-Anweisung zur Verfügung. Die vorgestellte Form des Debuggings eignet sich besonders gut, um das Verhalten der Faulheit zu observieren. <a href="http://www.ittc.ku.edu/~andygill/papers/Hood00.pdf">Veröffentlichung</a></p>
<h3 id="nebenläufigkeitausnahmebehandlungforeign-function-interface">Nebenläufigkeit/Ausnahmebehandlung/Foreign Function Interface</h3>
<h4 id="tackling-the-awkward-squad---s.-p.-jones-2010">Tackling the awkward squad - S. P. Jones (2010)</h4>
<p>Die Arbeit zeigt, wie einige Konzepte der imperativen Programmierung in Haskell integriert werden. Zuerst wird illustriert, wie die IO-Monade implementiert ist und wie diese formal modelliert werden kann. Daneben werden noch Konzepte wie veränderbare Speicherzellen, Nebenläufigkeit, Ausnahmebehandlung und das Foreign Function Interface (FFI) vorgestellt. Das FFI stellt ein Konzept zur Verfügung, um andere Programmiersprachen, zum Beispiel C, an Haskell anzubinden. Es handelt sich bei der Arbeit um Lecture Notes, die Simon Peyton Jones bereits im Jahr 2000 bei einer Summer School verwendet hat. Das Dokument wurde seitdem mehrfach überarbeitet und an den aktuellen Stand angepasst. <a href="http://research.microsoft.com/en-us/um/people/simonpj/Papers/marktoberdorf/mark.pdf.gz">Veröffentlichung</a></p>
<h4 id="concurrent-haskell---s.-p.-jones-and-a.-gordon-and-s.-finne-1996">Concurrent haskell - S. P. Jones and A. Gordon and S. Finne (1996)</h4>
<p>Die Arbeit stellt die Bibliothek Concurrent Haskell vor. Diese Bibliothek kann genutzt werden, um nebenläufige Programme, also Programme mit Threads und geteilten Ressourcen, in Haskell zu schreiben. Während das Abstraktionsniveau der Bibliothek relativ niedrig ist, da es sich um die erste Bibliothek dieser Art für Haskell handelt, sind Konzepte wie geteilte Variable und Semaphore so klar umgesetzt, dass die Bibliothek sich immer noch gut eignet, um grundlegende Algorithmen der nebenläufigen Programmierung klar zu modellieren. <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/concurrent-haskell.pdf">Veröffentlichung</a></p>
<h4 id="composable-memory-transactions---t.-harris-and-s.-marlow-and-s.-peyton-jones-and-m.-herlihy-2005">Composable memory transactions - T. Harris and S. Marlow and S. Peyton-Jones and M. Herlihy (2005)</h4>
<p>Diese Arbeit stellt das Konzept des Software Transactional Memory (STM) vor. Dieses Konzept lehnt sich an das Transaktionskonzept aus dem Bereich der Datenbanken an und kann genutzt werden, um einfacher nebenläufige Programme zu schreiben. Dabei werden Änderungen an geteilten Variablen nur vorgenommen, wenn alle beteiligten Threads einen konsistenten Blick auf die Werte der veränderten Variablen hatten. Auf diese Weise können nebenläufige Programme auf einer hohen Abstraktionsebene implementiert werden. Das STM-Konzept wurde auch für andere Programmiersprachen implementiert, konnte sich dort aber, auf Grund von Seiteneffekten, die nicht mit diesem Ansatz harmonieren, nicht durchsetzen. <a href="https://cs.uwaterloo.ca/~Brecht/courses/702/Possible-Readings/transactional-memory/composable-mem-trans-ppopp-2005.pdf">Veröffentlichung</a></p>
<h3 id="security">Security</h3>
<h4 id="two-can-keep-a-secret-if-one-of-them-uses-haskell---a.-russo-2015">Two can keep a secret, if one of them uses Haskell - A. Russo (2015)</h4>
<p>In dieser Arbeit wird eine Bibliothek für <em>Mandatory Access Control (MAC)</em> oder <em>Information-Flow Control (IFC)</em> vorgestellt. Während der erste Begriff aus dem Bereich der Betriebssysteme stammt, kommt der zweite Begriff aus dem Bereich der Programmiersprachen. Die Arbeit zeigt, wie man mit Hilfe des Typsystems von Haskell eine Bibliothek entwerfen kann, die nur eingeschränkten Zugriff auf gewisse Informationen erlaubt. <a href="https://pdfs.semanticscholar.org/4be7/7d8e77c95deac350e757220c45c051ace4f5.pdf">Veröffentlichung</a></p>
<h3 id="domain-specific-languages">Domain Specific Languages</h3>
<h4 id="monadic-parsing-in-haskell---g.-hutton-and-e.-meijer-1998">Monadic parsing in Haskell - G. Hutton and E. Meijer (1998)</h4>
<p>Diese Arbeit stellt die Idee der Parserkombinatoren vor. Ein Parser ist eine Funktion, die eine Zeichenkette analysiert, zerlegt und in einen strukturierten Datentyp umwandelt. Parserkombinatoren bieten die Möglichkeit einen solchen Parser einfach zu definieren, indem die zur Verfügung gestellten Kombinatoren verwendet werden. Die Idee der Parserkombinatoren wurde inzwischen in einer Vielzahl von Programmiersprachen implementiert, so gibt es Bibliotheken für Parserkombinatoren zum Beispiel in Java, C#, Ruby, C++, Python und JavaScript. <a href="http://www.cs.nott.ac.uk/~pszgmh/pearl.pdf">Veröffentlichung</a></p>
<h4 id="probabilistic-functional-programming-in-haskell---m.-erwig-and-s.-kollmansberger-2006">Probabilistic functional programming in Haskell - M. Erwig and S. Kollmansberger (2006)</h4>
<p>Probabilistische Programmiersprachen erlauben es, einfach die Berechnung von Wahrscheinlichkeiten zu modellieren. Solche Programmiersprachen werden zum Beispiel im Bereich der künstlichen Intelligenz zur Modellierung von neuronalen Netzen genutzt. Die Arbeit demonstriert, wie man in Haskell eine Bibliothek zur probabilistischen Programmierung einfach mit Hilfe einer monadischen Abstraktion implementieren kann. <a href="http://icerote.net/doc/library/programming/fp/Probabilistic%20functional%20programming%20in%20Haskell.pdf">Veröffentlichung</a></p>
<h3 id="web-entwicklung">Web-Entwicklung</h3>
<h4 id="type-level-web-apis-with-servant---a.-mestanogullari-and-s.-hahn-and-j.-k.-arni-and-a.-löh-2015">Type-Level Web APIs with Servant - A. Mestanogullari and S. Hahn and J. K. Arni and A. Löh (2015)</h4>
<p>Servant ist eine Haskell-Bibliothek zur Entwicklung von Http-Servern. Die Bibliothek stellt Konzepte zur Verfügung, um typsicher Http-Schnittstellen zu beschreiben. Wird an der Beschreibung eine Änderung vorgenommen, kann das Programm erst wieder übersetzt werden, wenn die Dienste, die die Schnittstelle nutzen, ebenfalls angepasst sind. Da diese Arbeit vergleichsweise aktuell ist, kommen einige der aktuelleren Typ-Erweiterungen von Haskell zum Einsatz. Zum einen kann man an dieser Arbeit schön sehen, was man mit Hilfe dieser Erweiterungen alles ausdrücken kann, zum anderen muss man in Kauf nehmen, dass man sich in einige der Erweiterungen zumindest teilweise einlesen muss. <a href="http://alpmestan.com/servant/servant-wgp.pdf">Veröffentlichung</a></p>
<h4 id="vorstellung-der-programmiersprache-elm">Vorstellung der Programmiersprache Elm</h4>
<p>Die Programmiersprache Elm ist im Rahmen einer Masterarbeit entstanden und ist stark an Haskell angelehnt. Die Sprache ist als Alternative für die Entwicklung des Frontends von Webanwendungen gedacht. Die Sprache setzte ursprünglich die Konzepte der funktional reaktiven Programmierung ein. Da es keine gut lesbare Veröffentlichung zu Elm gibt, muss als Bestandteil dieses Themas eine Literaturrecherche betrieben werden, um nutzbare Quellen zu finden. Neben der Einordnung der Sprache in den Bereich der Webentwicklung sollte ein Vergleich zu Haskell gezogen werden. <a href="http://elm-lang.org">Internetseite</a></p>
<h4 id="vorstellung-der-programmiersprache-purescript">Vorstellung der Programmiersprache PureScript</h4>
<p>Die Programmiersprache PureScript ist ebenfalls sehr eng an die Programmiersprache Haskell angelehnt. Die Sprache wird nach JavaScript übersetzt und ist als Alternative für JavaScript gedacht. Ein Ziel der Entwicklung war ein Compiler, der gut lesbaren JavaScript-Code erzeugt. Da es keine Veröffentlichung zu PureScript gibt, muss als Bestandteil dieses Themas eine Literaturrecherche betrieben werden, um nutzbare Quellen zu finden. Neben der Einordnung der Sprache in den Bereich der Webentwicklung sollte ein Vergleich zu Haskell gezogen werden. <a href="http://www.purescript.org">Internetseite</a></p>
<h3 id="weitere-programmiersprachen">Weitere Programmiersprachen</h3>
<h4 id="vorstellung-der-programmiersprache-coq">Vorstellung der Programmiersprache Coq</h4>
<p>Coq ist eine funktionale Programmiersprache, die außerdem einen interaktiven Beweisassistenten zur Verfügung stellt, um Aussagen über die Programme zu beweisen. Das heißt, man kann zum Beispiel funktionale Programme in Coq schreiben und dann Aussagen über diese Programme beweisen. Ein Beweis besteht dabei aus einer Reihe von Schritten, die man ebenfalls in die Programmdatei schreibt. Der Compiler überprüft dann beim Übersetzen des Programms, ob die Schritte des Beweises richtig sind. Man kann mit Hilfe von Coq aber nicht nur Aussagen über funktionale Programme beweisen. So wurde zum Beispiel mit Hilfe von Coq die Korrektheit eines <a href="http://compcert.inria.fr">C-Compilers</a> bewiesen, der zum Beispiel bei der Entwicklung von hoch-sicherheitskritischen Systemen wie Atomkraftwerken zum Einsatz kommt. Die Korrektheit des C-Compilers stellt sicher, dass der C-Compiler bei der Übersetzung und Optimierung des Codes die Bedeutung des Programms nicht verändert. <a href="https://coq.inria.fr">Internetseite</a></p>

        </div>

        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
